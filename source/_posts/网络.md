---
uuid: 5
title: 网络
categories:
- js
tags:
- tcp/ip
---
### TCP/IP
> TCP协议保证数据传输可靠性方式有： 
  1. 校验和
     > 检测数据在传输过程中的变化，如果收到检测有差错TCP将丢弃。
  2. 确认应答 + 序列号
     > 给发送的每一个包进行编号，接收方对数据包进行排序。
  3. 超时重传
     > 发送方没有接收到响应报文原因： 1.数据在传输过程中由于网络问题直接全体丢包，接收方没有接收到；2.接收方收到了响应数据，但是发送的报文响应由于网络丢包了。
     > 当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到就会进行重发。
  4. 流量控制（可变大小的滑动窗口协议）
     > TCP连接的每一方都有固定大小的缓存空间，TCP接收端只允许发送端发送接收端缓冲区能接纳的数据，如果接收端处理来不及能提示发送方降低发送速率防止丢包。
  5. 拥塞控制
     > 发送方发送数据前对比接收方发过来的即时窗口，取小，**慢启动**，拥塞避免，拥塞发送，快速恢复。

### 跨域
> 浏览器的同源策略限制
> 同源策略是一种约定，两个页面具有相同的协议、域名和端口。

#### 非同源限制
> 读取不到非同源网页的cookie、localstorage、indexDB
> 无法向非同源网页发送请求
> 无法操作非同源网页的dom

#### 解决跨域方法
1. **document.domain**,设置两个相同值就可以共享cookie，此方案仅限主域相同（document.domain = xxx）
2. **window.postMessage()**,页面和其他打开的新窗口进行数据传递、多窗口消息传递、页面与嵌套的iframe消息传递。
3. **jsonp**是服务端和客户端跨源通信的常用方法。只支持get请求。
     > 核心思想：通过添加一个<scritpt>元素，向服务器请求json数据，服务器收到请求后将数据放在指定的名字回调函数参数位置传回来。
4. **CORS**跨域资源共享，
    > 普通跨域请求： 服务器设置ACAO
    > 带cookie跨域请求：前后台都需设置（前端设置withCredentials）
5. **proxy**代理

### 从输入URL到页面渲染
1. 输入url
2. 查找缓存（浏览器缓存=》系统缓存=》路由缓存）：查找缓存中是否有该地址页面，有则显示没有则进行下一步
3. DNS域名解析：解析该URL中的域名对应的ip地址
4. 建立TCP连接：解析ip地址后，根据ip地址和默认端口80，与服务器建立tcp连接
5. 发起http请求：浏览器发起读取文件的http请求，该请求作为tcp三次握手的第三次数据发送给服务器
6. 服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
7. 关闭tcp连接：通过4次挥手释放tcp连接
8. 浏览器渲染：解析html内容并渲染（css解析不会阻塞html解析，但是会阻塞html的渲染，因为css和html解析合成一起之后才能渲染）
    > 构建DOM树：词法分析然后解析成DOM树是由dom元素及属性节点组成，树的根是document对象
    > 构建css规则树
    > 构建render树
    > 布局
    > 绘制
9. js引擎解析过程：
    > 创建window对象
    > 加载文件
    > 预编译
    > 解释执行



 
 









